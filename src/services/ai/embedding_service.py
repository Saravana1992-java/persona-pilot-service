import asyncio
from typing import Optional, List

from sentence_transformers import SentenceTransformer

from src.config import ic_logging
from src.constants.embedding_models import EmbeddingModels

sentence_transformers_model = "multi-qa-mpnet-base-cos-v1"


class EmbeddingService:
    """
    Class for managing the Text Embedding Model.

    This class leverages the Text Embedding Model to generate embeddings for text based on the specified
    task type.

    Attributes:
        bean_id (str): An identifier for the instance of this class, typically used for logging or debugging purposes.
        model (multi-qa-mpnet-base-cos-v1): The multi-qa-mpnet-base-cos-v1 Model object used for generating embeddings.
        name (str): The name of the embedding model being used.
        dim (int): The dimension of the embeddings generated by the model.

    Methods:
        to_embeddings(texts: List[str], task_type: EmbeddingsTaskType) -> List[float]:
            Generates embeddings for the provided list of texts based on the specified task type. Returns a list of
            embedding vectors.
        vectorize_texts(texts: str) -> List[float]:
            A convenience method that wraps `to_embeddings` for a single string input. Returns the embedding vector
            for the input text.
        apply_async_to_series(series: List[str]) -> List[List[float]]:
            Asynchronously processes a list of texts, generating embeddings for each. Useful for batch processing of
            text data.
        vectorize_data(data: dict) -> dict:
            Processes a dictionary of data, extracting text from specified fields, generating embeddings, and updating
            the dictionary with embedding vectors. Returns the updated dictionary with added embedding vector fields.
    """

    def __init__(self, bean_id):
        self.bean_id = bean_id
        self.model = SentenceTransformer(sentence_transformers_model)
        self.name = EmbeddingModels.sentence_transformers.name
        self.dim = 256

    async def to_embeddings(self, texts: List[str]):
        filtered_texts = [text for text in texts if text.strip()]
        if not filtered_texts:
            ic_logging.get_logger(__name__).info("No valid text content provided for embedding.")
            filtered_texts = "None"
        embeddings = self.model.encode(sentences=filtered_texts)
        ic_logging.get_logger(__name__).debug("embeddings created successfully:: length = " + str(len(embeddings)))
        return embeddings[0].values

    async def vectorize_texts(self, texts):
        return await self.to_embeddings(texts=[texts])

    async def apply_async_to_series(self, series):
        results = await asyncio.gather(*(self.vectorize_texts(texts) for texts in series))
        return results

    async def vectorize_data(self, data):
        ic_logging.get_logger(__name__).info(f"Create embedding using {sentence_transformers_model}")
        # Create Vector for the Semantic searchable fields
        titles = data["title"]
        title_vectors = await self.apply_async_to_series(titles)
        data["title_vector"] = title_vectors

        descriptions = data["description"]
        description_vectors = await self.apply_async_to_series(descriptions)
        data["description_vector"] = description_vectors
        ic_logging.get_logger(__name__).info(f"Embedding created using {sentence_transformers_model} successfully")
        return data
